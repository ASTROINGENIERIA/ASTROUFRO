package alma.acs.tmcdb;
// Generated Dec 3, 2018 9:54:59 PM by Hibernate Tools 4.3.1.Final


import alma.hibernate.util.StringEnumUserType;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import org.hibernate.annotations.Parameter;
import org.hibernate.annotations.Type;
import org.hibernate.annotations.TypeDef;

/**
 * Computer generated by hbm2java
 */
@SuppressWarnings("serial")
@Entity
@Table(name="`COMPUTER`"
)
@TypeDef(name="ComputerProcessorType", typeClass=StringEnumUserType.class,
   parameters={ @Parameter(name="enumClassName", value="alma.acs.tmcdb.ComputerProcessorType") })
public class Computer extends NetworkDevice implements java.io.Serializable {


     protected ComputerProcessorType processorType;
     protected Boolean realTime;
     protected Boolean diskless;
     private Set<SnmpTrapSink> snmpTrapSinks = new HashSet<SnmpTrapSink>(0);
     private Set<AcsService> acsServices = new HashSet<AcsService>(0);
     private Set<Container> containers = new HashSet<Container>(0);

    public Computer() {
    }
   

    
    @Column(name="`PROCESSORTYPE`", nullable=false, length=3)
	@Type(type="ComputerProcessorType")
    public ComputerProcessorType getProcessorType() {
        return this.processorType;
    }
    
    public void setProcessorType(ComputerProcessorType processorType) {    
        if( propertyChangeSupport != null )
            propertyChangeSupport.firePropertyChange("processorType", this.processorType, this.processorType = processorType);
        else
            this.processorType = processorType;
    }


    
    @Column(name="`REALTIME`", nullable=false)
    public Boolean getRealTime() {
        return this.realTime;
    }
    
    public void setRealTime(Boolean realTime) {    
        if( propertyChangeSupport != null )
            propertyChangeSupport.firePropertyChange("realTime", this.realTime, this.realTime = realTime);
        else
            this.realTime = realTime;
    }


    
    @Column(name="`DISKLESS`", nullable=false)
    public Boolean getDiskless() {
        return this.diskless;
    }
    
    public void setDiskless(Boolean diskless) {    
        if( propertyChangeSupport != null )
            propertyChangeSupport.firePropertyChange("diskless", this.diskless, this.diskless = diskless);
        else
            this.diskless = diskless;
    }


@OneToMany(fetch=FetchType.LAZY, mappedBy="computer")
    public Set<SnmpTrapSink> getSnmpTrapSinks() {
        return this.snmpTrapSinks;
    }
    
    public void setSnmpTrapSinks(Set<SnmpTrapSink> snmpTrapSinks) {    
    	this.snmpTrapSinks = snmpTrapSinks;
    }

	public void addSnmpTrapSinks(Set<SnmpTrapSink> elements) {
		if( this.snmpTrapSinks != null )
			for(Iterator<SnmpTrapSink> it = elements.iterator(); it.hasNext(); )
				addSnmpTrapSinkToSnmpTrapSinks((SnmpTrapSink)it.next());
	}

	public void addSnmpTrapSinkToSnmpTrapSinks(SnmpTrapSink element) {
		if( !this.snmpTrapSinks.contains(element) ) {
			this.snmpTrapSinks.add(element);
		}
	}


@OneToMany(fetch=FetchType.LAZY, mappedBy="computer")
    public Set<AcsService> getAcsServices() {
        return this.acsServices;
    }
    
    public void setAcsServices(Set<AcsService> acsServices) {    
    	this.acsServices = acsServices;
    }

	public void addAcsServices(Set<AcsService> elements) {
		if( this.acsServices != null )
			for(Iterator<AcsService> it = elements.iterator(); it.hasNext(); )
				addAcsServiceToAcsServices((AcsService)it.next());
	}

	public void addAcsServiceToAcsServices(AcsService element) {
		if( !this.acsServices.contains(element) ) {
			this.acsServices.add(element);
		}
	}


@OneToMany(fetch=FetchType.LAZY, mappedBy="computer")
    public Set<Container> getContainers() {
        return this.containers;
    }
    
    public void setContainers(Set<Container> containers) {    
    	this.containers = containers;
    }

	public void addContainers(Set<Container> elements) {
		if( this.containers != null )
			for(Iterator<Container> it = elements.iterator(); it.hasNext(); )
				addContainerToContainers((Container)it.next());
	}

	public void addContainerToContainers(Container element) {
		if( !this.containers.contains(element) ) {
			this.containers.add(element);
		}
	}





}


